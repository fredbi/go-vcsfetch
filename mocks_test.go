// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package vcsfetch

import (
	"net/url"
	"sync"
)

// Ensure that MockLocator does implement Locator.
// If this is not the case, regenerate this file with mockery.
var _ Locator = &MockLocator{}

// MockLocator is a mock implementation of Locator.
//
//	func TestSomethingThatUsesLocator(t *testing.T) {
//
//		// make and configure a mocked Locator
//		mockedLocator := &MockLocator{
//			HasAuthFunc: func() bool {
//				panic("mock out the HasAuth method")
//			},
//			IsLocalFunc: func() bool {
//				panic("mock out the IsLocal method")
//			},
//			PathFunc: func() string {
//				panic("mock out the Path method")
//			},
//			RepoURLFunc: func() *url.URL {
//				panic("mock out the RepoURL method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			VersionFunc: func() string {
//				panic("mock out the Version method")
//			},
//		}
//
//		// use mockedLocator in code that requires Locator
//		// and then make assertions.
//
//	}
type MockLocator struct {
	// HasAuthFunc mocks the HasAuth method.
	HasAuthFunc func() bool

	// IsLocalFunc mocks the IsLocal method.
	IsLocalFunc func() bool

	// PathFunc mocks the Path method.
	PathFunc func() string

	// RepoURLFunc mocks the RepoURL method.
	RepoURLFunc func() *url.URL

	// StringFunc mocks the String method.
	StringFunc func() string

	// VersionFunc mocks the Version method.
	VersionFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// HasAuth holds details about calls to the HasAuth method.
		HasAuth []struct {
		}
		// IsLocal holds details about calls to the IsLocal method.
		IsLocal []struct {
		}
		// Path holds details about calls to the Path method.
		Path []struct {
		}
		// RepoURL holds details about calls to the RepoURL method.
		RepoURL []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Version holds details about calls to the Version method.
		Version []struct {
		}
	}
	lockHasAuth sync.RWMutex
	lockIsLocal sync.RWMutex
	lockPath    sync.RWMutex
	lockRepoURL sync.RWMutex
	lockString  sync.RWMutex
	lockVersion sync.RWMutex
}

// HasAuth calls HasAuthFunc.
func (mock *MockLocator) HasAuth() bool {
	if mock.HasAuthFunc == nil {
		panic("MockLocator.HasAuthFunc: method is nil but Locator.HasAuth was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHasAuth.Lock()
	mock.calls.HasAuth = append(mock.calls.HasAuth, callInfo)
	mock.lockHasAuth.Unlock()
	return mock.HasAuthFunc()
}

// HasAuthCalls gets all the calls that were made to HasAuth.
// Check the length with:
//
//	len(mockedLocator.HasAuthCalls())
func (mock *MockLocator) HasAuthCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHasAuth.RLock()
	calls = mock.calls.HasAuth
	mock.lockHasAuth.RUnlock()
	return calls
}

// IsLocal calls IsLocalFunc.
func (mock *MockLocator) IsLocal() bool {
	if mock.IsLocalFunc == nil {
		panic("MockLocator.IsLocalFunc: method is nil but Locator.IsLocal was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsLocal.Lock()
	mock.calls.IsLocal = append(mock.calls.IsLocal, callInfo)
	mock.lockIsLocal.Unlock()
	return mock.IsLocalFunc()
}

// IsLocalCalls gets all the calls that were made to IsLocal.
// Check the length with:
//
//	len(mockedLocator.IsLocalCalls())
func (mock *MockLocator) IsLocalCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsLocal.RLock()
	calls = mock.calls.IsLocal
	mock.lockIsLocal.RUnlock()
	return calls
}

// Path calls PathFunc.
func (mock *MockLocator) Path() string {
	if mock.PathFunc == nil {
		panic("MockLocator.PathFunc: method is nil but Locator.Path was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPath.Lock()
	mock.calls.Path = append(mock.calls.Path, callInfo)
	mock.lockPath.Unlock()
	return mock.PathFunc()
}

// PathCalls gets all the calls that were made to Path.
// Check the length with:
//
//	len(mockedLocator.PathCalls())
func (mock *MockLocator) PathCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPath.RLock()
	calls = mock.calls.Path
	mock.lockPath.RUnlock()
	return calls
}

// RepoURL calls RepoURLFunc.
func (mock *MockLocator) RepoURL() *url.URL {
	if mock.RepoURLFunc == nil {
		panic("MockLocator.RepoURLFunc: method is nil but Locator.RepoURL was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRepoURL.Lock()
	mock.calls.RepoURL = append(mock.calls.RepoURL, callInfo)
	mock.lockRepoURL.Unlock()
	return mock.RepoURLFunc()
}

// RepoURLCalls gets all the calls that were made to RepoURL.
// Check the length with:
//
//	len(mockedLocator.RepoURLCalls())
func (mock *MockLocator) RepoURLCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRepoURL.RLock()
	calls = mock.calls.RepoURL
	mock.lockRepoURL.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *MockLocator) String() string {
	if mock.StringFunc == nil {
		panic("MockLocator.StringFunc: method is nil but Locator.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedLocator.StringCalls())
func (mock *MockLocator) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Version calls VersionFunc.
func (mock *MockLocator) Version() string {
	if mock.VersionFunc == nil {
		panic("MockLocator.VersionFunc: method is nil but Locator.Version was just called")
	}
	callInfo := struct {
	}{}
	mock.lockVersion.Lock()
	mock.calls.Version = append(mock.calls.Version, callInfo)
	mock.lockVersion.Unlock()
	return mock.VersionFunc()
}

// VersionCalls gets all the calls that were made to Version.
// Check the length with:
//
//	len(mockedLocator.VersionCalls())
func (mock *MockLocator) VersionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockVersion.RLock()
	calls = mock.calls.Version
	mock.lockVersion.RUnlock()
	return calls
}
